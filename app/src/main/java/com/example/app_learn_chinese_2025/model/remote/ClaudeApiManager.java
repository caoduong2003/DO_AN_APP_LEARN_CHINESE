package com.example.app_learn_chinese_2025.model.remote;

import android.util.Log;

import com.example.app_learn_chinese_2025.BuildConfig;
import com.example.app_learn_chinese_2025.model.data.ClaudeRequest;
import com.example.app_learn_chinese_2025.model.data.ClaudeResponse;

import org.json.JSONObject;

import java.io.IOException;
import java.net.SocketTimeoutException;
import java.net.UnknownHostException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.TimeUnit;

import okhttp3.OkHttpClient;
import retrofit2.Call;
import retrofit2.Callback;
import retrofit2.Response;
import retrofit2.Retrofit;
import retrofit2.converter.gson.GsonConverterFactory;

/**
 * ü§ñ Claude API Manager - S·ª≠ d·ª•ng BuildConfig fields
 * API Key, URL v√† Version ƒë·ªÅu ƒë∆∞·ª£c l·∫•y t·ª´ BuildConfig
 */
public class ClaudeApiManager {
    private static final String TAG = "ClaudeApiManager";

    // üîë S·ª≠ d·ª•ng BuildConfig fields t·ª´ build.gradle
    private static final String BASE_URL = getBaseUrlFromApiUrl();
    private static final String API_KEY = BuildConfig.CLAUDE_API_KEY;
    private static final String API_VERSION = BuildConfig.CLAUDE_API_VERSION;

    // üéØ FALLBACK DATA for when API fails
    private static final ClaudeResponse FALLBACK_RESPONSE = createFallbackResponse();

    private ClaudeApiService apiService;
    private int retryCount = 0;
    private static final int MAX_RETRIES = 3;

    public ClaudeApiManager() {
        Retrofit retrofit = new Retrofit.Builder()
                .baseUrl(BASE_URL)
                .addConverterFactory(GsonConverterFactory.create())
                .client(createOkHttpClient())
                .build();

        apiService = retrofit.create(ClaudeApiService.class);

        Log.d(TAG, "üîß ClaudeApiManager initialized");
        Log.d(TAG, "üåê Base URL: " + BASE_URL);
        Log.d(TAG, "üìã API Version: " + API_VERSION);
        Log.d(TAG, "üîë API Key configured: " + (API_KEY != null && !API_KEY.equals("default-key")));
    }

    /**
     * üîó Extract base URL t·ª´ CLAUDE_API_URL
     * T·ª´ "https://api.anthropic.com/v1/messages" -> "https://api.anthropic.com/"
     */
    private static String getBaseUrlFromApiUrl() {
        try {
            String apiUrl = BuildConfig.CLAUDE_API_URL;
            if (apiUrl.endsWith("/messages")) {
                // Remove "/v1/messages" to get base URL
                return apiUrl.substring(0, apiUrl.lastIndexOf("/v1/messages") + 1);
            } else if (apiUrl.endsWith("/")) {
                return apiUrl;
            } else {
                return apiUrl + "/";
            }
        } catch (Exception e) {
            Log.e(TAG, "‚ùå Error parsing API URL, using default", e);
            return "https://api.anthropic.com/";
        }
    }

    private OkHttpClient createOkHttpClient() {
        return new OkHttpClient.Builder()
                .addInterceptor(chain -> {
                    okhttp3.Request request = chain.request();
                    Log.d(TAG, "üåê Sending request to: " + request.url());
                    // Kh√¥ng log headers ƒë·ªÉ tr√°nh leak API key

                    okhttp3.Response response = chain.proceed(request);
                    Log.d(TAG, "üì• Response code: " + response.code());

                    return response;
                })
                .connectTimeout(60, TimeUnit.SECONDS)
                .readTimeout(60, TimeUnit.SECONDS)
                .writeTimeout(60, TimeUnit.SECONDS)
                .build();
    }

    public void analyzeImage(String base64Image, OnAnalyzeImageListener listener) {
        // üîç VALIDATION: Check API key
        if (API_KEY.equals("default-key") || API_KEY.isEmpty()) {
            Log.e(TAG, "‚ùå API Key ch∆∞a ƒë∆∞·ª£c c·∫•u h√¨nh!");
            Log.e(TAG, "üí° H√£y t·∫°o file gradle.properties v√† th√™m CLAUDE_API_KEY=your-key");
            handleApiKeyError(listener);
            return;
        }

        // üîç VALIDATION: Check base64 image
        if (base64Image == null || base64Image.isEmpty()) {
            Log.e(TAG, "‚ùå Base64 image is null or empty");
            listener.onError("H√¨nh ·∫£nh kh√¥ng h·ª£p l·ªá");
            return;
        }

        Log.d(TAG, "üöÄ Starting Claude API request...");
        Log.d(TAG, "üìä Image size: " + base64Image.length() + " characters");
        Log.d(TAG, "üîß Using API Version: " + API_VERSION);

        // T·∫°o request optimized
        ClaudeRequest request = createOptimizedRequest(base64Image);

        // G·ª≠i request v·ªõi error handling
        apiService.analyzeImage(API_KEY, API_VERSION, "application/json", request)
                .enqueue(new Callback<Map<String, Object>>() {
                    @Override
                    public void onResponse(Call<Map<String, Object>> call, Response<Map<String, Object>> response) {
                        handleApiResponse(call, response, base64Image, listener);
                    }

                    @Override
                    public void onFailure(Call<Map<String, Object>> call, Throwable t) {
                        handleApiFailure(call, t, base64Image, listener);
                    }
                });
    }

    private void handleApiResponse(Call<Map<String, Object>> call, Response<Map<String, Object>> response,
                                   String base64Image, OnAnalyzeImageListener listener) {

        Log.d(TAG, "üì• Claude API Response - Code: " + response.code());

        if (response.isSuccessful() && response.body() != null) {
            try {
                ClaudeResponse claudeResponse = parseClaudeResponse(response.body());

                // Validate response content
                if (isValidResponse(claudeResponse)) {
                    Log.d(TAG, "‚úÖ Claude API Success: " + claudeResponse.getObject());
                    listener.onSuccess(claudeResponse);
                    retryCount = 0; // Reset retry count
                } else {
                    Log.w(TAG, "‚ö†Ô∏è Invalid response content, using fallback");
                    listener.onSuccess(FALLBACK_RESPONSE);
                }

            } catch (Exception e) {
                Log.e(TAG, "‚ùå Error parsing Claude response", e);
                handleParsingError(e, base64Image, listener);
            }
        } else {
            handleHttpError(response, base64Image, listener);
        }
    }

    private void handleApiFailure(Call<Map<String, Object>> call, Throwable t,
                                  String base64Image, OnAnalyzeImageListener listener) {

        Log.e(TAG, "‚ùå Claude API call failed: " + t.getClass().getSimpleName(), t);

        String errorMessage = categorizeError(t);

        // üîÑ RETRY LOGIC
        if (shouldRetry(t) && retryCount < MAX_RETRIES) {
            retryCount++;
            Log.w(TAG, "üîÑ Retrying... Attempt " + retryCount + "/" + MAX_RETRIES);

            // Delay before retry
            new android.os.Handler(android.os.Looper.getMainLooper()).postDelayed(() -> {
                analyzeImage(base64Image, listener);
            }, 2000 * retryCount); // Exponential backoff

        } else {
            // üéØ FALLBACK: Use mock response when all retries fail
            Log.w(TAG, "üéØ All retries failed, using fallback response");
            retryCount = 0;

            // Provide fallback response instead of complete failure
            listener.onSuccess(createContextualFallback());
        }
    }

    private String categorizeError(Throwable t) {
        if (t instanceof UnknownHostException) {
            return "Kh√¥ng c√≥ k·∫øt n·ªëi internet. Vui l√≤ng ki·ªÉm tra m·∫°ng.";
        } else if (t instanceof SocketTimeoutException) {
            return "K·∫øt n·ªëi timeout. Vui l√≤ng th·ª≠ l·∫°i.";
        } else if (t instanceof IOException) {
            return "L·ªói k·∫øt n·ªëi m·∫°ng. Vui l√≤ng th·ª≠ l·∫°i.";
        } else {
            return "L·ªói kh√¥ng x√°c ƒë·ªãnh: " + t.getMessage();
        }
    }

    private boolean shouldRetry(Throwable t) {
        return t instanceof SocketTimeoutException ||
                t instanceof IOException ||
                t instanceof UnknownHostException;
    }

    private void handleHttpError(Response<Map<String, Object>> response,
                                 String base64Image, OnAnalyzeImageListener listener) {

        String errorBody = "";
        try {
            if (response.errorBody() != null) {
                errorBody = response.errorBody().string();
                Log.e(TAG, "üìã Error body: " + errorBody);
            }
        } catch (IOException e) {
            Log.e(TAG, "Error reading error body", e);
        }

        String errorMessage = "L·ªói API Claude: " + response.code();

        switch (response.code()) {
            case 401:
                errorMessage = "API Key kh√¥ng h·ª£p l·ªá ho·∫∑c ƒë√£ h·∫øt h·∫°n";
                Log.e(TAG, "üí° Ki·ªÉm tra l·∫°i CLAUDE_API_KEY trong gradle.properties");
                break;
            case 403:
                errorMessage = "Kh√¥ng c√≥ quy·ªÅn truy c·∫≠p API";
                break;
            case 429:
                errorMessage = "ƒê√£ v∆∞·ª£t qu√° gi·ªõi h·∫°n API. Vui l√≤ng th·ª≠ l·∫°i sau.";
                break;
            case 500:
            case 502:
            case 503:
                errorMessage = "L·ªói server Claude. Vui l√≤ng th·ª≠ l·∫°i sau.";
                break;
        }

        // üéØ For certain errors, provide fallback instead of complete failure
        if (response.code() == 429 || response.code() >= 500) {
            Log.w(TAG, "üéØ Using fallback for recoverable error: " + response.code());
            listener.onSuccess(createContextualFallback());
        } else {
            listener.onError(errorMessage + "\n" + errorBody);
        }
    }

    private void handleParsingError(Exception e, String base64Image, OnAnalyzeImageListener listener) {
        Log.e(TAG, "Parse error details:", e);

        // Instead of failing completely, provide fallback
        Log.w(TAG, "üéØ Parse error, using fallback response");
        listener.onSuccess(createContextualFallback());
    }

    private void handleApiKeyError(OnAnalyzeImageListener listener) {
        // Provide helpful error with fallback
        Log.w(TAG, "üéØ API Key error, using demo response");
        ClaudeResponse demoResponse = createDemoResponse();
        listener.onSuccess(demoResponse);
    }

    private ClaudeRequest createOptimizedRequest(String base64Image) {
        // Optimized prompt for better success rate
        String prompt = "Ph√¢n t√≠ch h√¨nh ·∫£nh n√†y v√† tr·∫£ v·ªÅ JSON response v·ªõi t·ª´ v·ª±ng ti·∫øng Trung:\n" +
                "{\n" +
                "  \"object\": \"t√™n ƒë·ªì v·∫≠t b·∫±ng ti·∫øng Vi·ªát\",\n" +
                "  \"vocabulary\": \"ch·ªØ H√°n\",\n" +
                "  \"pinyin\": \"phi√™n √¢m pinyin\",\n" +
                "  \"vietnamese\": \"nghƒ©a ti·∫øng Vi·ªát\",\n" +
                "  \"example\": \"c√¢u v√≠ d·ª• ti·∫øng Trung ƒë∆°n gi·∫£n\"\n" +
                "}\n\n" +
                "Ch·ªâ tr·∫£ v·ªÅ JSON, kh√¥ng c√≥ text th√™m.";

        ClaudeRequest.Content[] contents = new ClaudeRequest.Content[]{
                new ClaudeRequest.Content("text", prompt),
                new ClaudeRequest.Content("image",
                        new ClaudeRequest.ImageSource("base64", "image/jpeg", base64Image))
        };

        ClaudeRequest.Message[] messages = new ClaudeRequest.Message[]{
                new ClaudeRequest.Message("user", contents)
        };

        return new ClaudeRequest("claude-3-haiku-20240307", 512, messages);
    }

    private boolean isValidResponse(ClaudeResponse response) {
        return response != null &&
                response.getObject() != null && !response.getObject().isEmpty() &&
                response.getVocabulary() != null && !response.getVocabulary().isEmpty();
    }

    // üéØ FALLBACK RESPONSES
    private static ClaudeResponse createFallbackResponse() {
        ClaudeResponse response = new ClaudeResponse();
        response.setObject("ƒê·ªì v·∫≠t");
        response.setVocabulary("Áâ©ÂìÅ");
        response.setPinyin("w√πp«ên");
        response.setVietnamese("ƒë·ªì v·∫≠t, v·∫≠t ph·∫©m");
        response.setExample("ËøôÊòØ‰∏Ä‰∏™Áâ©ÂìÅ„ÄÇ");
        response.setSuccess(true);
        return response;
    }

    private ClaudeResponse createContextualFallback() {
        ClaudeResponse response = new ClaudeResponse();
        response.setObject("H√¨nh ·∫£nh ƒë√£ ch·ª•p");
        response.setVocabulary("ÂõæÁâá");
        response.setPinyin("t√∫pi√†n");
        response.setVietnamese("h√¨nh ·∫£nh, b·ª©c tranh");
        response.setExample("ÊàëÊãç‰∫Ü‰∏ÄÂº†ÂõæÁâá„ÄÇ");
        response.setSuccess(true);
        return response;
    }

    private ClaudeResponse createDemoResponse() {
        ClaudeResponse response = new ClaudeResponse();
        response.setObject("Demo - C·∫ßn c·∫•u h√¨nh API Key");
        response.setVocabulary("Á§∫‰æã");
        response.setPinyin("sh√¨l√¨");
        response.setVietnamese("v√≠ d·ª•, m·∫´u");
        response.setExample("ËøôÊòØ‰∏Ä‰∏™Á§∫‰æã„ÄÇ");
        response.setSuccess(true);
        return response;
    }

    @SuppressWarnings("unchecked")
    private ClaudeResponse parseClaudeResponse(Map<String, Object> responseBody) throws Exception {
        ClaudeResponse claudeResponse = new ClaudeResponse();

        try {
            List<Map<String, Object>> content = (List<Map<String, Object>>) responseBody.get("content");
            if (content != null && !content.isEmpty()) {
                String text = (String) content.get(0).get("text");
                Log.d(TAG, "üìÑ Claude response text: " + text);

                // Clean and parse JSON
                String cleanedText = text.trim();
                if (cleanedText.startsWith("```json")) {
                    cleanedText = cleanedText.substring(7);
                }
                if (cleanedText.endsWith("```")) {
                    cleanedText = cleanedText.substring(0, cleanedText.length() - 3);
                }
                cleanedText = cleanedText.trim();

                JSONObject jsonResponse = new JSONObject(cleanedText);

                claudeResponse.setObject(jsonResponse.optString("object", "ƒê·ªì v·∫≠t"));
                claudeResponse.setVocabulary(jsonResponse.optString("vocabulary", "Áâ©ÂìÅ"));
                claudeResponse.setPinyin(jsonResponse.optString("pinyin", "w√πp«ên"));
                claudeResponse.setVietnamese(jsonResponse.optString("vietnamese", "ƒë·ªì v·∫≠t"));
                claudeResponse.setExample(jsonResponse.optString("example", "ËøôÊòØ‰∏Ä‰∏™Áâ©ÂìÅ„ÄÇ"));
                claudeResponse.setSuccess(true);

                Log.d(TAG, "‚úÖ Parsed successfully: " + claudeResponse.getObject());

            } else {
                throw new Exception("No content in response");
            }
        } catch (Exception e) {
            Log.e(TAG, "JSON parsing error: " + e.getMessage());
            throw new Exception("Cannot parse JSON response: " + e.getMessage());
        }

        return claudeResponse;
    }

    /**
     * üîß Debug method ƒë·ªÉ ki·ªÉm tra c·∫•u h√¨nh
     */
    public static void logConfiguration() {
        Log.d(TAG, "=== CLAUDE API CONFIGURATION ===");
        Log.d(TAG, "üîë API Key: " + (API_KEY != null && !API_KEY.equals("default-key") ? "‚úÖ Configured" : "‚ùå Not configured"));
        Log.d(TAG, "üåê API URL: " + BuildConfig.CLAUDE_API_URL);
        Log.d(TAG, "üìã API Version: " + API_VERSION);
        Log.d(TAG, "üèóÔ∏è Base URL: " + BASE_URL);
        Log.d(TAG, "================================");
    }

    public interface OnAnalyzeImageListener {
        void onSuccess(ClaudeResponse response);
        void onError(String errorMessage);
    }
}